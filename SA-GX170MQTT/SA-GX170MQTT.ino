#include <Arduino.h>
#include <IRsend.h>
#include <ESP8266WiFi.h>
#include <ESP8266mDNS.h>
#include <PubSubClient.h>
#include <ESP8266WebServer.h>
#include <AutoConnect.h>

//DEFINITIONS
#define irLed 5 //D1
#define onBoardLED 2
#define optoSpeakersA 4 //D2
#define optoSpeakersB 0 //D3
#define optoPhono 15 //D5

#define speakersAPayload 1
#define speakersBPayload 2
#define phonoPayload 3

#ifndef STASSID
#define STAMqttServerAddress ""
#define STAMqttUserName ""
#define STAMqttPwd ""
#define STAMqttClientID "Technics SA-GX170 test"
#endif

const char* mqttServerAddress = STAMqttServerAddress;
const char* mqttUserName = STAMqttUserName;
const char* mqttPwd = STAMqttPwd;
const char* mqttClientID = STAMqttClientID;

//REMOTE CONTROL RAW DATA (PRONTO RAW PROTOCOL)

//POWER
uint16_t powerC[104] = { 0x0000, 0x0070, 0x0000, 0x0032, 0x0080, 0x003f, 0x0011, 0x000f, 0x0011, 0x002f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x002f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x002f, 0x0011, 0x000f, 0x0011, 0x002f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x002f, 0x0011, 0x000f, 0x0011, 0x002f, 0x0011, 0x002f, 0x0011, 0x002f, 0x0011, 0x002f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x002f, 0x0011, 0x000f, 0x0011, 0x002f, 0x0011, 0x002f, 0x0011, 0x002f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x002f, 0x0011, 0x0aa8 };

//TV
uint16_t tvC[104] = { 0x0000, 0x0070, 0x0000, 0x0032, 0x0080, 0x0040, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0030, 0x0010, 0x0030, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0030, 0x0010, 0x0030, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0aa9 };

//VOL+
uint16_t volPlusC[104] = { 0x0000, 0x0070, 0x0000, 0x0032, 0x0080, 0x0040, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0aa9 };

//VOL-
uint16_t volMinusC[104] = { 0x0000, 0x0070, 0x0000, 0x0032, 0x0080, 0x003f, 0x0011, 0x000f, 0x0011, 0x002f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x002f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x002f, 0x0011, 0x000f, 0x0011, 0x002f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x002f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x002f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x002f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x000f, 0x0011, 0x002f, 0x0011, 0x0aa8 };

//VCR1
uint16_t vcr1C[104] = { 0x0000, 0x0070, 0x0000, 0x0032, 0x0080, 0x0040, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0030, 0x0010, 0x0030, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0030, 0x0010, 0x0030, 0x0010, 0x0030, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0aa9 };

//TAPE MONITOR
uint16_t tMonC[104] = { 0x0000, 0x0070, 0x0000, 0x0032, 0x0080, 0x0040, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0aba };

//CD
uint16_t cdC[104] = { 0x0000, 0x0070, 0x0000, 0x0032, 0x0080, 0x0040, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0aba };

//TUNER
uint16_t tunerC[104] = { 0x0000, 0x0070, 0x0000, 0x0032, 0x0080, 0x0040, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0aba };

//MUTE
uint16_t muteC[104] = { 0x0000, 0x0070, 0x0000, 0x0032, 0x0080, 0x0040, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0030, 0x0010, 0x0aba };

//INITIALIZATIONS
WiFiClient espClient;
IRsend irsend(irLed);
PubSubClient client(espClient);
ESP8266WebServer server;                              
AutoConnect       portal(server);   
AutoConnectConfig config;           
AutoConnectAux    hello;      

static const char HELLO_PAGE[] PROGMEM = R"(
{ "title": "Technics SA-GX170", "uri": "/", "menu": true, "element": [
    { "name": "caption", "type": "ACText", "value": "<h2>Technics SA-GX170</h2>",  "style": "text-align:center;color:#2f4f4f;padding:10px;" },
    { "name": "content", "type": "ACText", "value": "ESP8266 management page" } ]
}
)";      

String strTopic;
String strPayload;

//HARDWARE BUTTONS (OPTOCOUPLERS)
void hwButtons(int code) {
  switch (code) {
    case speakersAPayload:
      Serial.println("Pressing button: Speakers A");
      digitalWrite(optoSpeakersA, HIGH);
      delay(50);
      digitalWrite(optoSpeakersA, LOW);
      Serial.println("Released button: Speakers A");
      break;
    case speakersBPayload:
      Serial.println("Pressing button: Speakers B");
      digitalWrite(optoSpeakersB, HIGH);
      delay(50);
      digitalWrite(optoSpeakersB, LOW);
      Serial.println("Released button: Speakers B");
      break;
    case phonoPayload:
      Serial.println("Pressing button: phono");
      digitalWrite(optoPhono, HIGH);
      delay(50);
      digitalWrite(optoPhono, LOW);
      Serial.println("Released button: phono");
      break;
  }
}

//IR COMMANDS
void irCommands(int cmnd) {
  switch (cmnd) {
    case 1:
      Serial.println("Sent signal: Power");
      irsend.sendPronto(powerC, 104);
      break;
    case 2:
      Serial.println("Sent signal: TV");
      irsend.sendPronto(tvC, 104);
      break;
    case 3:
      Serial.println("Sent signal: VCR1");
      irsend.sendPronto(vcr1C, 104);
      irsend.sendPronto(tMonC, 104);
      break;
    case 4:
      Serial.println("Sent signal: TAPE MONITOR");
      irsend.sendPronto(tMonC, 104);
      break;
    case 5:
      Serial.println("Sent signal: CD");
      irsend.sendPronto(cdC, 104);
      irsend.sendPronto(tMonC, 104);
      break;
    case 6:
      Serial.println("Sent signal: TUNER");
      irsend.sendPronto(tunerC, 104);
      irsend.sendPronto(tMonC, 104);
      break;
    case 7:
      Serial.println("Sent signal: MUTE");
      irsend.sendPronto(muteC, 104);
      break;
  }
}

//IR VOLUME COMMANDS
//VOLUME DOWN TO 0 = 100
void irVolumeCommands(int cmnd, int steps) {
  switch (cmnd) {
    case '1':
      Serial.println("Sent signal: VOL+");
      Serial.println("Volume steps: " + (String)steps);
      Serial.println(steps);
      for (int i = 0; i < steps; i++) {
        irsend.sendPronto(volPlusC, 104);
      }
      break;
    case '2':
      Serial.println("Sent signalL: VOL-");
      Serial.println("Volume steps: " + (String)steps);
      for (int i = 0; i < steps; i++) {
        irsend.sendPronto(volMinusC, 104);
      }
      break;
  }
}

//MQTT CALLBACK FUNCTION
void mqttCallback(char* topic, byte* payload, unsigned int length) {
  payload[length] = '\0';
  strTopic = String((char*)topic);
  int payloadInt = (int)payload;
  if (strTopic == "cmnd/technics/hwbuttons") {
    hwButtons(atoi((char*)payload));
  }

  //IR Commands
  if (strTopic == "cmnd/technics/ir") {
    irCommands(atoi((char*)payload));
  }

  //IR VOLUME COMMANDS
  if (strTopic == "cmnd/technics/ir/vol") {
    char* payloadChar = (char*)payload;
    char *payloadWFE = &payloadChar[2];
    irVolumeCommands((int)payload[0], atoi(payloadWFE));
  }

  digitalWrite(irLed, LOW);
}

//MQTT RECONNECT
void mqttReconnect() {
  while (!client.connected()) {
    Serial.print("Attempting MQTT connection...");
    if (client.connect(mqttClientID, mqttUserName, mqttPwd)) {
      Serial.println("Connected to Home Assistant MQTT Broker");
      //MQTT SUBSCRIPTIONS
      client.subscribe("avail/technics");
      client.subscribe("cmnd/technics/hwbuttons");
      client.subscribe("cmnd/technics/ir");
      client.subscribe("cmnd/technics/ir/vol");
      client.publish("avail/technics", "Online");
    } else {
      Serial.print("Failed: ");
      Serial.print(client.state());
      Serial.println("Trying again in 5 seconds...");
      delay(5000);
    }
  }
}

void setup() {
  Serial.begin(115200);
  Serial.println("Booting");
  pinMode(onBoardLED, OUTPUT);
  digitalWrite(onBoardLED, LOW);
  pinMode(optoSpeakersA, OUTPUT);
  digitalWrite(optoSpeakersA, LOW);
  pinMode(optoSpeakersB, OUTPUT);
  digitalWrite(optoSpeakersB, LOW);
  pinMode(optoPhono, OUTPUT);
  digitalWrite(optoPhono, LOW);

  client.setServer(mqttServerAddress, 1883);
  client.setCallback(mqttCallback);
  digitalWrite(onBoardLED, LOW);
  irsend.begin();
  config.ota = AC_OTA_BUILTIN;      
  portal.config(config);           
  hello.load(HELLO_PAGE);         
  portal.join({ hello });           
  portal.begin();    
  
  Serial.println("Ready");
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());
}

void loop() {
  if (!client.connected()) {
    mqttReconnect();
  }
  client.loop();
  portal.handleClient(); 
}
